/* -*- mode: js; indent-tabs-mode: nil; -*- */
//
// Copyright (c) 2015 Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
"use strict";

const Q = require('q');

function RpcSocket(socket) {
    this._socket = socket;
    this._knownStubs = {};
    this._knownProxies = {};
    this._pendingCalls = {};
    this._inCall = false;
    this._newObjects = [];
    this._callId = 0;

    this._socket.on('data', this._handleMessage.bind(this));

    this._socket.on('end', function() {
        this.emit('end');
    }.bind(this));
    this._socket.on('close', function(hadError) {
        this.emit('close', hadError);
    }.bind(this));
}

RpcSocket.prototype.end = function(callback) {
    this._socket.end(callback);
}

RpcSocket.prototype.destroy = function() {
    this._socket.destroy();
}

RpcSocket.prototype.addStub = function(obj) {
    if ((obj instanceof RpcStub) || !obj.$rpcMethods || obj.$rpcId !== undefined)
        throw new TypeError('Invalid stub object');

    var stub = new RpcStub(obj, obj.$rpcMethods);
    this._knownStubs[stub.$rpcId] = stub;
    if (this._inCall) {
        this._newObjects.push({control:'new-object', obj: stub.$rpcId,
                               methods: stub.methods});
    } else {
        this._socket.write({control:'new-object', obj: stub.$rpcId,
                            methods: stub.methods});
    }
    return stub.$rpcId;
}

RpcSocket.prototype._marshalArgument = function(arg) {
    if (typeof arg !== 'object' || arg === null)
        return arg;

    if (Array.isArray(arg)) {
        return arg.map(this._marshalArgument.bind(this));
    } else if (arg.$rpcId !== undefined) {
        return {$rpcId:arg.$rpcId};
    } else if (arg.$rpcMethods) {
        var id = this.addStub(arg);
        return {$rpcId:id};
    } else {
        return arg;
    }
}

RpcSocket.prototype._unmarshalArgument = function(arg) {
    if (typeof arg !== 'object' || arg === null)
        return arg;

    if (Array.isArray(arg)) {
        return arg.map(this._unmarshalArgument.bind(this));
    } else if (arg.$rpcId !== undefined) {
        var stub = this._knownStubs[arg.$rpcId];
        if (stub !== undefined)
            return stub.object;
        var proxy = this._knownProxies[arg.$rpcId];
        if (proxy !== undefined)
            return proxy;
        throw new Error('Invalid object ' + arg.$rpcId);
    } else {
        return arg;
    }
}

RpcSocket.prototype.call = function(obj, method, args) {
    if (this._inCall)
        throw new Error('Re-entrant calls are not supported');

    this._inCall = true;
    var marshalled = args.map(this._marshalArgument.bind(this));
    this._newObjects.forEach(function(obj) {
        this._socket.write(obj);
    }, this);
    this._newObjects = [];
    this._inCall = false;

    var id = this._callId++;
    var call = Q.defer();
    this._pendingCalls[id] = call;
    this._socket.write({control:'call', id: id,
                        obj: obj, method: method,
                        params: marshalled});
    return call.promise;
}

RpcSocket.prototype._handleCall = function(msg) {
    if (msg.id === undefined) {
        console.error('Malformed method call');
        return;
    }

    Q.try(function() {
        if (!(msg.obj in this._knownStubs))
            throw new Error('Invalid object');

        if (!Array.isArray(msg.params))
            throw new Error('Malformed method call');

        var stub = this._knownStubs[msg.obj];
        var unmarshalled = msg.params.map(this._unmarshalArgument.bind(this));
        var method = msg.method;

        if (method.substr(0,4) === 'get ') {
            if (unmarshalled.length != 0)
                throw new Error('Wrong number of arguments, expected 0');

            return stub.get([method.substr(4)]);
        } else if (method.substr(0,4) === 'set ') {
            if (unmarshalled.length != 1)
                throw new Error('Wrong number of arguments, expected 1');

            stub.set([method.substr(4)], unmarshalled[0]);
        } else {
            return stub.call(method, unmarshalled);
        }
    }.bind(this)).then(function(reply) {
        if (msg.id !== null) {
            this._socket.write({control:'reply', id: msg.id,
                                reply: this._marshalArgument(reply)});
        }
    }.bind(this)).catch(function(error) {
        if (msg.id !== null) {
            if (error.name === 'SyntaxError') {
                this._socket.write({control:'reply', id: msg.id,
                                    error: 'SyntaxError',
                                    fileName: error.fileName,
                                    lineNumber: error.lineNumber,
                                    message: error.message});
            } else if (error.message) {
                //console.error(error.stack);
                this._socket.write({control:'reply', id: msg.id,
                                    error: error.message});
            } else {
                this._socket.write({control:'reply', id: msg.id,
                                    error: String(error)});
            }
        } else {
            console.error('Discarded error from RPC call: ' + error.message);
        }
    }.bind(this)).done();
}

RpcSocket.prototype._handleReply = function(msg) {
    if (msg.id === undefined || msg.id === null) {
        console.error('Malformed method reply');
        return;
    }

    if (!(msg.id in this._pendingCalls)) {
        console.error(msg.id + ' is not a pending method call');
        return;
    }

    var call = this._pendingCalls[msg.id];
    delete this._pendingCalls[msg.id];
    try {
        if (msg.error) {
            if (msg.error === 'SyntaxError')
                throw new SyntaxError(msg.message, msg.fileName, msg.lineNumber);
            else
                throw new Error(msg.error);
        }

        call.resolve(this._unmarshalArgument(msg.reply));
    } catch(e) {
        call.reject(e);
    }
}

RpcSocket.prototype._handleMessage = function(msg) {
    switch (msg.control) {
    case 'new-object':
        if (msg.obj in this._knownProxies)
            return;

        this._knownProxies[msg.obj] = new RpcProxy(this, msg.obj, msg.methods);
        return;

    case 'call':
        this._handleCall(msg);
        return;

    case 'reply':
        this._handleReply(msg);
        return;
    }
}

var stubCnt = 1;

function RpcStub(object, methods) {
    if (!(this instanceof RpcStub)) return new RpcStub(object, methods);

    var cnt = stubCnt ++;
    if (cnt >= 65536)
        throw new Error('Too many stubs');
    this.$rpcId = (process.pid << 16) + cnt;
    object.$rpcId = this.$rpcId;
    this.object = object;
    this.methods = methods;
}

RpcStub.prototype._validateCall = function(method) {
    if (this.methods.indexOf(method) < 0)
        throw new Error('Invalid method ' + method);
}

RpcStub.prototype.get = function(name) {
    this._validateCall('get ' + name);
    return this.object[name];
}

RpcStub.prototype.set = function(name, value) {
    // NOTE: not a typo here, 'get foo' allows both get and set of foo
    this._validateCall('get ' + name);
    this.object[name] = value;
}

RpcStub.prototype.call = function(method, args) {
    this._validateCall(method);
    return this.object[method].apply(this.object, args);
}

function RpcProxy(socket, id, methods) {
    if (!(this instanceof RpcProxy)) return new RpcProxy(socket);

    this.$rpcId = id;
    this._socket = socket;

    methods.forEach(function(method) {
        if (method.substr(0,4) === 'get ') {
            var name = method.substr(4);
            Object.defineProperty(this, name,
                                  { configurable: true,
                                    enumerable: true,
                                    get: function() {
                                        return this._socket.call(this.$rpcId, 'get ' + name, []);
                                    },
                                    set: function(v) {
                                        return this._socket.call(this.$rpcId, 'set ' + name, [v]);
                                    }
                                  });
        } else {
            this[method] = function() {
                return this._socket.call(this.$rpcId, method, Array.prototype.slice.call(arguments));
            };
        }
    }, this);
}

module.exports = {
    Socket: RpcSocket,
    Stub: RpcStub,
};
